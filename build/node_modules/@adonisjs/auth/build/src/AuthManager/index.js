"use strict";
/*
 * @adonisjs/auth
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthManager = void 0;
const utils_1 = require("@poppinss/utils");
const Auth_1 = require("../Auth");
/**
 * Auth manager to manage guards and providers object. The extend API can
 * be used to add custom guards and providers
 */
class AuthManager {
    constructor(application, config) {
        this.application = application;
        this.config = config;
        /**
         * Extended set of testing clients
         */
        this.extendedClients = new Map();
        /**
         * Extended set of providers
         */
        this.extendedProviders = new Map();
        /**
         * Extend set of guards
         */
        this.extendedGuards = new Map();
        /**
         * Reference to the default guard
         */
        this.defaultGuard = this.config.guard;
        const validator = new utils_1.ManagerConfigValidator(config, 'auth', 'config/auth');
        validator.validateDefault('guard');
        validator.validateList('guards', 'guard');
    }
    /**
     * Verifies and returns an instance of the event emitter
     */
    getEmitter() {
        const hasEmitter = this.application.container.hasBinding('Adonis/Core/Event');
        if (!hasEmitter) {
            throw new utils_1.Exception('"Adonis/Core/Event" is required by the auth provider');
        }
        return this.application.container.use('Adonis/Core/Event');
    }
    /**
     * Lazily makes an instance of the lucid provider
     */
    makeLucidProvider(config) {
        return new (require('../UserProviders/Lucid').LucidProvider)(this.application, config);
    }
    /**
     * Lazily makes an instance of the database provider
     */
    makeDatabaseProvider(config) {
        const Database = this.application.container.use('Adonis/Lucid/Database');
        return new (require('../UserProviders/Database').DatabaseProvider)(this.application, config, Database);
    }
    /**
     * Returns an instance of the extended provider
     */
    makeExtendedProvider(mapping, config) {
        const providerCallback = this.extendedProviders.get(config.driver);
        if (!providerCallback) {
            throw new utils_1.Exception(`Invalid provider "${config.driver}"`);
        }
        return providerCallback(this, mapping, config);
    }
    /**
     * Lazily makes an instance of the token database provider
     */
    makeTokenDatabaseProvider(config) {
        const Database = this.application.container.use('Adonis/Lucid/Database');
        return new (require('../TokenProviders/Database').TokenDatabaseProvider)(config, Database);
    }
    /**
     * Lazily makes an instance of the token redis provider
     */
    makeTokenRedisProvider(config) {
        if (!this.application.container.hasBinding('Adonis/Addons/Redis')) {
            throw new utils_1.Exception('"@adonisjs/redis" is required to use the "redis" token provider');
        }
        const Redis = this.application.container.use('Adonis/Addons/Redis');
        return new (require('../TokenProviders/Redis').TokenRedisProvider)(config, Redis);
    }
    /**
     * Returns an instance of the session guard
     */
    makeSessionGuard(mapping, config, provider, ctx) {
        const { SessionGuard } = require('../Guards/Session');
        return new SessionGuard(mapping, config, this.getEmitter(), provider, ctx);
    }
    /**
     * Returns an instance of the session guard
     */
    makeOatGuard(mapping, config, provider, ctx) {
        const { OATGuard } = require('../Guards/Oat');
        const tokenProvider = this.makeTokenProviderInstance(config.tokenProvider);
        return new OATGuard(mapping, config, this.getEmitter(), provider, ctx, tokenProvider);
    }
    /**
     * Returns an instance of the basic auth guard
     */
    makeBasicAuthGuard(mapping, config, provider, ctx) {
        const { BasicAuthGuard } = require('../Guards/BasicAuth');
        return new BasicAuthGuard(mapping, config, this.getEmitter(), provider, ctx);
    }
    /**
     * Returns an instance of the extended guard
     */
    makeExtendedGuard(mapping, config, provider, ctx) {
        const guardCallback = this.extendedGuards.get(config.driver);
        if (!guardCallback) {
            throw new utils_1.Exception(`Invalid guard driver "${config.driver}" property`);
        }
        return guardCallback(this, mapping, config, provider, ctx);
    }
    /**
     * Returns an instance of the session client
     */
    makeSessionClient(mapping, config, provider) {
        const { SessionClient } = require('../Clients/Session');
        return new SessionClient(mapping, config, provider);
    }
    /**
     * Returns an instance of the session client
     */
    makeOatClient(mapping, config, provider) {
        const { OATClient } = require('../Clients/Oat');
        const tokenProvider = this.makeTokenProviderInstance(config.tokenProvider);
        return new OATClient(mapping, config, provider, tokenProvider);
    }
    /**
     * Returns an instance of the extended client
     */
    makeExtendedClient(mapping, config, provider) {
        const clientCallback = this.extendedClients.get(config.driver);
        if (!clientCallback) {
            throw new utils_1.Exception(`Invalid guard driver "${config.driver}" property`);
        }
        return clientCallback(this, mapping, config, provider);
    }
    /**
     * Makes client instance for the defined driver inside the
     * mapping config.
     */
    makeClientInstance(mapping, mappingConfig, provider) {
        if (!mappingConfig || !mappingConfig.driver) {
            throw new utils_1.Exception('Invalid auth config, missing "driver" property');
        }
        switch (mappingConfig.driver) {
            case 'session':
                return this.makeSessionClient(mapping, mappingConfig, provider);
            case 'oat':
                return this.makeOatClient(mapping, mappingConfig, provider);
            case 'basic':
                throw new utils_1.Exception('There is no testing client for basic auth. Use "request.basicAuth" method instead');
            default:
                return this.makeExtendedClient(mapping, mappingConfig, provider);
        }
    }
    /**
     * Makes instance of a provider based upon the driver value
     */
    makeUserProviderInstance(mapping, providerConfig) {
        if (!providerConfig || !providerConfig.driver) {
            throw new utils_1.Exception('Invalid auth config, missing "provider" or "provider.driver" property');
        }
        switch (providerConfig.driver) {
            case 'lucid':
                return this.makeLucidProvider(providerConfig);
            case 'database':
                return this.makeDatabaseProvider(providerConfig);
            default:
                return this.makeExtendedProvider(mapping, providerConfig);
        }
    }
    /**
     * Makes instance of a provider based upon the driver value
     */
    makeTokenProviderInstance(providerConfig) {
        if (!providerConfig || !providerConfig.driver) {
            throw new utils_1.Exception('Invalid auth config, missing "tokenProvider" or "tokenProvider.driver" property');
        }
        switch (providerConfig.driver) {
            case 'database':
                return this.makeTokenDatabaseProvider(providerConfig);
            case 'redis':
                return this.makeTokenRedisProvider(providerConfig);
            default:
                throw new utils_1.Exception(`Invalid token provider "${providerConfig.driver}"`);
        }
    }
    /**
     * Makes guard instance for the defined driver inside the
     * mapping config.
     */
    makeGuardInstance(mapping, mappingConfig, provider, ctx) {
        if (!mappingConfig || !mappingConfig.driver) {
            throw new utils_1.Exception('Invalid auth config, missing "driver" property');
        }
        switch (mappingConfig.driver) {
            case 'session':
                return this.makeSessionGuard(mapping, mappingConfig, provider, ctx);
            case 'oat':
                return this.makeOatGuard(mapping, mappingConfig, provider, ctx);
            case 'basic':
                return this.makeBasicAuthGuard(mapping, mappingConfig, provider, ctx);
            default:
                return this.makeExtendedGuard(mapping, mappingConfig, provider, ctx);
        }
    }
    /**
     * Make an instance of a given mapping for the current HTTP request.
     */
    makeMapping(ctx, mapping) {
        const mappingConfig = this.config.guards[mapping];
        if (mappingConfig === undefined) {
            throw new utils_1.Exception(`Invalid guard "${mapping}". Make sure the guard is defined inside the config/auth file`);
        }
        const provider = this.makeUserProviderInstance(mapping, mappingConfig.provider);
        return this.makeGuardInstance(mapping, mappingConfig, provider, ctx);
    }
    /**
     * Returns an instance of the testing
     */
    client(mapping) {
        const mappingConfig = this.config.guards[mapping];
        if (mappingConfig === undefined) {
            throw new utils_1.Exception(`Invalid guard "${mapping}". Make sure the guard is defined inside the config/auth file`);
        }
        const provider = this.makeUserProviderInstance(mapping, mappingConfig.provider);
        return this.makeClientInstance(mapping, mappingConfig, provider);
    }
    /**
     * Returns an instance of the auth class for the current request
     */
    getAuthForRequest(ctx) {
        return new Auth_1.Auth(this, ctx);
    }
    extend(type, name, callback) {
        if (type === 'provider') {
            this.extendedProviders.set(name, callback);
            return;
        }
        if (type === 'client') {
            this.extendedClients.set(name, callback);
            return;
        }
        if (type === 'guard') {
            this.extendedGuards.set(name, callback);
            return;
        }
    }
}
exports.AuthManager = AuthManager;
